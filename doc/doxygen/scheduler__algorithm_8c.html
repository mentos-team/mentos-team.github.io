<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MentOS: /home/enrico/repository/personal/mentos/mentos/src/process/scheduler_algorithm.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MentOS
   &#160;<span id="projectnumber">0.7.3</span>
   </div>
   <div id="projectbrief">The Mentoring Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b4d46abdb8cafe1ad6c14fa0f9992e34.html">mentos</a></li><li class="navelem"><a class="el" href="dir_d299fed5c83b024e8b5c525a233be574.html">src</a></li><li class="navelem"><a class="el" href="dir_b2479b03a349f62f8285d50699dfa9b8.html">process</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">scheduler_algorithm.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Round Robin algorithm.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae88fdea60e151933ce52a92938897dac"><td class="memItemLeft" align="right" valign="top"><a id="ae88fdea60e151933ce52a92938897dac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#ae88fdea60e151933ce52a92938897dac">__DEBUG_HEADER__</a>&#160;&#160;&#160;&quot;[SCHALG]&quot;</td></tr>
<tr class="memdesc:ae88fdea60e151933ce52a92938897dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change header. <br /></td></tr>
<tr class="separator:ae88fdea60e151933ce52a92938897dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7dc04a8b1423d105b10f7af0720c"><td class="memItemLeft" align="right" valign="top"><a id="a785e7dc04a8b1423d105b10f7af0720c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a785e7dc04a8b1423d105b10f7af0720c">__DEBUG_LEVEL__</a>&#160;&#160;&#160;<a class="el" href="kernel__levels_8h.html#a4377191d729d923509b6953555776d80">LOGLEVEL_NOTICE</a></td></tr>
<tr class="memdesc:a785e7dc04a8b1423d105b10f7af0720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level. <br /></td></tr>
<tr class="separator:a785e7dc04a8b1423d105b10f7af0720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a02a1aee6047d6b8cb3ca6ffdc53908b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a02a1aee6047d6b8cb3ca6ffdc53908b5">__update_task_statistics</a> (<a class="el" href="structtask__struct.html">task_struct</a> *task)</td></tr>
<tr class="memdesc:a02a1aee6047d6b8cb3ca6ffdc53908b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates task execution statistics.  <a href="scheduler__algorithm_8c.html#a02a1aee6047d6b8cb3ca6ffdc53908b5">More...</a><br /></td></tr>
<tr class="separator:a02a1aee6047d6b8cb3ca6ffdc53908b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66987dac5222d777b8d3d5aefdc8d47b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a66987dac5222d777b8d3d5aefdc8d47b">__is_periodic_task</a> (<a class="el" href="structtask__struct.html">task_struct</a> *task)</td></tr>
<tr class="memdesc:a66987dac5222d777b8d3d5aefdc8d47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given task is actually a periodic task.  <a href="scheduler__algorithm_8c.html#a66987dac5222d777b8d3d5aefdc8d47b">More...</a><br /></td></tr>
<tr class="separator:a66987dac5222d777b8d3d5aefdc8d47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b29243c83a51084a36f613064171ff6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a9b29243c83a51084a36f613064171ff6">__scheduler_rr</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>, <a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a> skip_periodic)</td></tr>
<tr class="memdesc:a9b29243c83a51084a36f613064171ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Employs time-sharing, giving each job a time-slot, and is also preemptive since the scheduler forces the task out of the CPU once the time-slot expires.  <a href="scheduler__algorithm_8c.html#a9b29243c83a51084a36f613064171ff6">More...</a><br /></td></tr>
<tr class="separator:a9b29243c83a51084a36f613064171ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f81f0f8e255692f7db82330ce0c7f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#ab3f81f0f8e255692f7db82330ce0c7f9">__scheduler_priority</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>, <a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a> skip_periodic)</td></tr>
<tr class="memdesc:ab3f81f0f8e255692f7db82330ce0c7f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is a non-preemptive algorithm, where each task is assigned a priority. Processes with highest priority are executed first, while processes with same priority are executed on first-come/first-served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement.  <a href="scheduler__algorithm_8c.html#ab3f81f0f8e255692f7db82330ce0c7f9">More...</a><br /></td></tr>
<tr class="separator:ab3f81f0f8e255692f7db82330ce0c7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab811d3e006ed1c0e1c3eb259018cf157"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#ab811d3e006ed1c0e1c3eb259018cf157">__scheduler_cfs</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>, <a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a> skip_periodic)</td></tr>
<tr class="memdesc:ab811d3e006ed1c0e1c3eb259018cf157"><td class="mdescLeft">&#160;</td><td class="mdescRight">It aims at giving a fair share of CPU time to processes, and achieves that by associating a virtual runtime to each of them. It always tries to run the task with the smallest vruntime (i.e., the task which executed least so far). It always tries to split up CPU time between runnable tasks as close to "ideal multitasking hardware" as possible.  <a href="scheduler__algorithm_8c.html#ab811d3e006ed1c0e1c3eb259018cf157">More...</a><br /></td></tr>
<tr class="separator:ab811d3e006ed1c0e1c3eb259018cf157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f713f27080375be84fcd764f9c75cf7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a3f713f27080375be84fcd764f9c75cf7">__scheduler_aedf</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>)</td></tr>
<tr class="memdesc:a3f713f27080375be84fcd764f9c75cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the task with the earliest absolute deadline among all the ready tasks.  <a href="scheduler__algorithm_8c.html#a3f713f27080375be84fcd764f9c75cf7">More...</a><br /></td></tr>
<tr class="separator:a3f713f27080375be84fcd764f9c75cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade79fbd32d6cf8b052433b4df928750c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#ade79fbd32d6cf8b052433b4df928750c">__scheduler_edf</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>)</td></tr>
<tr class="memdesc:ade79fbd32d6cf8b052433b4df928750c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the task with the earliest absolute DEADLINE among all the ready tasks. When a task was executed, and its period is starting again, it must be set as 'executable again', and its deadline and next_period must be updated.  <a href="scheduler__algorithm_8c.html#ade79fbd32d6cf8b052433b4df928750c">More...</a><br /></td></tr>
<tr class="separator:ade79fbd32d6cf8b052433b4df928750c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30db47a9f33a323450162ca560d16d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#ae30db47a9f33a323450162ca560d16d3">__scheduler_rm</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>)</td></tr>
<tr class="memdesc:ae30db47a9f33a323450162ca560d16d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the task with the earliest next PERIOD among all the ready tasks.  <a href="scheduler__algorithm_8c.html#ae30db47a9f33a323450162ca560d16d3">More...</a><br /></td></tr>
<tr class="separator:ae30db47a9f33a323450162ca560d16d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c738f5f181967fdfdee09339802cf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="scheduler__algorithm_8c.html#a17c738f5f181967fdfdee09339802cf7">scheduler_pick_next_task</a> (<a class="el" href="structrunqueue__t.html">runqueue_t</a> *<a class="el" href="scheduler_8c.html#acff3d7b3d3e372c44b9acb10ddc883f7">runqueue</a>)</td></tr>
<tr class="memdesc:a17c738f5f181967fdfdee09339802cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Picks the next task (in <a class="el" href="scheduler__algorithm_8c.html" title="Round Robin algorithm.">scheduler_algorithm.c</a>).  <a href="scheduler__algorithm_8c.html#a17c738f5f181967fdfdee09339802cf7">More...</a><br /></td></tr>
<tr class="separator:a17c738f5f181967fdfdee09339802cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Round Robin algorithm. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2014-2024 This file is distributed under the MIT License. See LICENSE.md for details. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a66987dac5222d777b8d3d5aefdc8d47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66987dac5222d777b8d3d5aefdc8d47b">&#9670;&nbsp;</a></span>__is_periodic_task()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a> __is_periodic_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given task is actually a periodic task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the task is periodic, false otherwise. </dd></dl>

</div>
</div>
<a id="a3f713f27080375be84fcd764f9c75cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f713f27080375be84fcd764f9c75cf7">&#9670;&nbsp;</a></span>__scheduler_aedf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_aedf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the task with the earliest absolute deadline among all the ready tasks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ab811d3e006ed1c0e1c3eb259018cf157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab811d3e006ed1c0e1c3eb259018cf157">&#9670;&nbsp;</a></span>__scheduler_cfs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_cfs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>skip_periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>It aims at giving a fair share of CPU time to processes, and achieves that by associating a virtual runtime to each of them. It always tries to run the task with the smallest vruntime (i.e., the task which executed least so far). It always tries to split up CPU time between runnable tasks as close to "ideal multitasking hardware" as possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
    <tr><td class="paramname">skip_periodic</td><td>tells the algorithm if there are periodic processes in the list, and in that case it needs to skip them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ade79fbd32d6cf8b052433b4df928750c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade79fbd32d6cf8b052433b4df928750c">&#9670;&nbsp;</a></span>__scheduler_edf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_edf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the task with the earliest absolute DEADLINE among all the ready tasks. When a task was executed, and its period is starting again, it must be set as 'executable again', and its deadline and next_period must be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="ab3f81f0f8e255692f7db82330ce0c7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f81f0f8e255692f7db82330ce0c7f9">&#9670;&nbsp;</a></span>__scheduler_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_priority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>skip_periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is a non-preemptive algorithm, where each task is assigned a priority. Processes with highest priority are executed first, while processes with same priority are executed on first-come/first-served basis. Priority can be decided based on memory requirements, time requirements or any other resource requirement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
    <tr><td class="paramname">skip_periodic</td><td>tells the algorithm if there are periodic processes in the list, and in that case it needs to skip them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure.</dd></dl>
<p>When implementing this algorithm, beware of the following pitfal. If you have the following runqueue (reports task position in the runqueue, priority and name): Position | Priority | Name 1 | 120 | init 2 | 120 | shell 3 | 122 | echo 4 | 128 | ps If you pick the first task every time (i.e., init), and use its prio (i.e., 120), what would happen if inside the for-loop when you check "if the entry
has a lower priority", you use a lesser-than sign? First, it will check against init itself, so 120 &lt; 120 is false. Then, it will check against shell, again, 120 &lt; 120 is false. As such, shell or the other processes will never be selected. There are different ways of solving this problem, each of which requires changes only inside this same function. Good luck. </p>

</div>
</div>
<a id="ae30db47a9f33a323450162ca560d16d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30db47a9f33a323450162ca560d16d3">&#9670;&nbsp;</a></span>__scheduler_rm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_rm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the task with the earliest next PERIOD among all the ready tasks. </p>
<p>When a task was executed, and its period is starting again, it must be set as 'executable again', and its deadline and next_period must be updated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="a9b29243c83a51084a36f613064171ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b29243c83a51084a36f613064171ff6">&#9670;&nbsp;</a></span>__scheduler_rr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtask__struct.html">task_struct</a>* __scheduler_rr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdbool_8h.html#a04dd5074964518403bf944f2b240a5f8">bool_t</a>&#160;</td>
          <td class="paramname"><em>skip_periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Employs time-sharing, giving each job a time-slot, and is also preemptive since the scheduler forces the task out of the CPU once the time-slot expires. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>list of all processes. </td></tr>
    <tr><td class="paramname">skip_periodic</td><td>tells the algorithm that periodic processes in the list should be skipped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next task on success, NULL on failure. </dd></dl>

</div>
</div>
<a id="a02a1aee6047d6b8cb3ca6ffdc53908b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a1aee6047d6b8cb3ca6ffdc53908b5">&#9670;&nbsp;</a></span>__update_task_statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void __update_task_statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtask__struct.html">task_struct</a> *&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates task execution statistics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c738f5f181967fdfdee09339802cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c738f5f181967fdfdee09339802cf7">&#9670;&nbsp;</a></span>scheduler_pick_next_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtask__struct.html">task_struct</a>* scheduler_pick_next_task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrunqueue__t.html">runqueue_t</a> *&#160;</td>
          <td class="paramname"><em>runqueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Picks the next task (in <a class="el" href="scheduler__algorithm_8c.html" title="Round Robin algorithm.">scheduler_algorithm.c</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">runqueue</td><td>Pointer to the runqueue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next task to execute. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
