<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MentOS: /home/enrico/repository/personal/mentos/mentos/inc/mem/zone_allocator.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MentOS
   &#160;<span id="projectnumber">0.7.3</span>
   </div>
   <div id="projectbrief">The Mentoring Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b4d46abdb8cafe1ad6c14fa0f9992e34.html">mentos</a></li><li class="navelem"><a class="el" href="dir_b043e71e4766e108b8d8f74323da14bd.html">inc</a></li><li class="navelem"><a class="el" href="dir_5b7d244f1504d91d097aeb486f1c4565.html">mem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">zone_allocator.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the Zone Allocator.  
<a href="#details">More...</a></p>

<p><a href="zone__allocator_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpage__t.html">page_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated.  <a href="structpage__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structzone__t.html">zone_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to differentiate memory zone.  <a href="structzone__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpg__data__t.html">pg_data_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to rapresent a memory node. In Uniform memory access (UMA) architectures there is only one node called contig_page_data.  <a href="structpg__data__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3da56390fe5721da921e57ad7919ec98"><td class="memItemLeft" align="right" valign="top"><a id="a3da56390fe5721da921e57ad7919ec98"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a3da56390fe5721da921e57ad7919ec98">page_count</a>(p)&#160;&#160;&#160;<a class="el" href="stdatomic_8h.html#a4b37dbfb4ace31a9604066dd5cc2b5f6">atomic_read</a>(&amp;(p)-&gt;count)</td></tr>
<tr class="memdesc:a3da56390fe5721da921e57ad7919ec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the page count. <br /></td></tr>
<tr class="separator:a3da56390fe5721da921e57ad7919ec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336322279fba288d356e7f9b56885ada"><td class="memItemLeft" align="right" valign="top"><a id="a336322279fba288d356e7f9b56885ada"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a336322279fba288d356e7f9b56885ada">set_page_count</a>(p,  v)&#160;&#160;&#160;<a class="el" href="stdatomic_8h.html#a43445a258aafc9662c9d60a6a24b68ed">atomic_set</a>(&amp;(p)-&gt;count, v)</td></tr>
<tr class="memdesc:a336322279fba288d356e7f9b56885ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the page count. <br /></td></tr>
<tr class="separator:a336322279fba288d356e7f9b56885ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc91ee5789762a2566abfb18bdbeeb86"><td class="memItemLeft" align="right" valign="top"><a id="adc91ee5789762a2566abfb18bdbeeb86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#adc91ee5789762a2566abfb18bdbeeb86">page_inc</a>(p)&#160;&#160;&#160;<a class="el" href="stdatomic_8h.html#ab83dad8ebc2695d2e144532a46c30eaa">atomic_inc</a>(&amp;(p)-&gt;count)</td></tr>
<tr class="memdesc:adc91ee5789762a2566abfb18bdbeeb86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increments the counter for the given page. <br /></td></tr>
<tr class="separator:adc91ee5789762a2566abfb18bdbeeb86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c48d855d736515abd9d160ec112e0b"><td class="memItemLeft" align="right" valign="top"><a id="af1c48d855d736515abd9d160ec112e0b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#af1c48d855d736515abd9d160ec112e0b">page_dec</a>(p)&#160;&#160;&#160;<a class="el" href="stdatomic_8h.html#a73e65633349beb8a9d6342d53f403791">atomic_dec</a>(&amp;(p)-&gt;count)</td></tr>
<tr class="memdesc:af1c48d855d736515abd9d160ec112e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements the counter for the given page. <br /></td></tr>
<tr class="separator:af1c48d855d736515abd9d160ec112e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ace2af291a76ffee949c3f3ee1a56faa1"><td class="memItemLeft" align="right" valign="top"><a id="ace2af291a76ffee949c3f3ee1a56faa1"></a>
typedef struct <a class="el" href="structpage__t.html">page_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#ace2af291a76ffee949c3f3ee1a56faa1">page_t</a></td></tr>
<tr class="memdesc:ace2af291a76ffee949c3f3ee1a56faa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated. <br /></td></tr>
<tr class="separator:ace2af291a76ffee949c3f3ee1a56faa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6859408e346d71f46cf0b65c83362016"><td class="memItemLeft" align="right" valign="top"><a id="a6859408e346d71f46cf0b65c83362016"></a>
typedef struct <a class="el" href="structzone__t.html">zone_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a6859408e346d71f46cf0b65c83362016">zone_t</a></td></tr>
<tr class="memdesc:a6859408e346d71f46cf0b65c83362016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to differentiate memory zone. <br /></td></tr>
<tr class="separator:a6859408e346d71f46cf0b65c83362016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f250c5edf8145bb822de791eb07930"><td class="memItemLeft" align="right" valign="top"><a id="ad9f250c5edf8145bb822de791eb07930"></a>
typedef struct <a class="el" href="structpg__data__t.html">pg_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#ad9f250c5edf8145bb822de791eb07930">pg_data_t</a></td></tr>
<tr class="memdesc:ad9f250c5edf8145bb822de791eb07930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure to rapresent a memory node. In Uniform memory access (UMA) architectures there is only one node called contig_page_data. <br /></td></tr>
<tr class="separator:ad9f250c5edf8145bb822de791eb07930"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a0fdf79ffb0b79648e58d693137ccfada"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfada">zone_type</a> { <a class="el" href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfadaae04e3071b5aefe12178a93c7c616dd8b">ZONE_NORMAL</a>
, <a class="el" href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfadaa274e4b70b8facd808390afd8833440f5">ZONE_HIGHMEM</a>
, <a class="el" href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfadaac210316b34bd6909d0a1b0126e39b286">__MAX_NR_ZONES</a>
 }</td></tr>
<tr class="memdesc:a0fdf79ffb0b79648e58d693137ccfada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration for <a class="el" href="structzone__t.html" title="Data structure to differentiate memory zone.">zone_t</a>.  <a href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfada">More...</a><br /></td></tr>
<tr class="separator:a0fdf79ffb0b79648e58d693137ccfada"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61f7fc07eb39b47fe33f8008050b1bda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a61f7fc07eb39b47fe33f8008050b1bda">find_nearest_order_greater</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> base_addr, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> amount)</td></tr>
<tr class="memdesc:a61f7fc07eb39b47fe33f8008050b1bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest order of memory allocation that can accommodate a given amount of memory.  <a href="zone__allocator_8h.html#a61f7fc07eb39b47fe33f8008050b1bda">More...</a><br /></td></tr>
<tr class="separator:a61f7fc07eb39b47fe33f8008050b1bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae118563b91978e181e76a04d77c50860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#ae118563b91978e181e76a04d77c50860">pmmngr_init</a> (<a class="el" href="structboot__info__t.html">boot_info_t</a> *<a class="el" href="kernel_8c.html#a6fb24e311419027d49f1cab853a9a9ac">boot_info</a>)</td></tr>
<tr class="memdesc:ae118563b91978e181e76a04d77c50860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical memory manager initialization.  <a href="zone__allocator_8h.html#ae118563b91978e181e76a04d77c50860">More...</a><br /></td></tr>
<tr class="separator:ae118563b91978e181e76a04d77c50860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04446abca7c9e3ddd590c6779952705e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a04446abca7c9e3ddd590c6779952705e">alloc_page_cached</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a04446abca7c9e3ddd590c6779952705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a cached page based on the given GFP mask.  <a href="zone__allocator_8h.html#a04446abca7c9e3ddd590c6779952705e">More...</a><br /></td></tr>
<tr class="separator:a04446abca7c9e3ddd590c6779952705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4eab4390517146b559c2abed5df0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a50f4eab4390517146b559c2abed5df0c">free_page_cached</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a50f4eab4390517146b559c2abed5df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a page allocated with alloc_page_cached.  <a href="zone__allocator_8h.html#a50f4eab4390517146b559c2abed5df0c">More...</a><br /></td></tr>
<tr class="separator:a50f4eab4390517146b559c2abed5df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0199ff865e2c2743b52925ba7ae94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a9c0199ff865e2c2743b52925ba7ae94a">__alloc_page_lowmem</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a9c0199ff865e2c2743b52925ba7ae94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free page frame, set it allocated and return the memory address of the page frame.  <a href="zone__allocator_8h.html#a9c0199ff865e2c2743b52925ba7ae94a">More...</a><br /></td></tr>
<tr class="separator:a9c0199ff865e2c2743b52925ba7ae94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1117639df92ae7df60b82abb6ef363a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a1117639df92ae7df60b82abb6ef363a0">free_page_lowmem</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr)</td></tr>
<tr class="memdesc:a1117639df92ae7df60b82abb6ef363a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given page frame address.  <a href="zone__allocator_8h.html#a1117639df92ae7df60b82abb6ef363a0">More...</a><br /></td></tr>
<tr class="separator:a1117639df92ae7df60b82abb6ef363a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a323b63ab21ca69fd1f38c87c9f020b6c">__alloc_pages_lowmem</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> order)</td></tr>
<tr class="memdesc:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated.  <a href="zone__allocator_8h.html#a323b63ab21ca69fd1f38c87c9f020b6c">More...</a><br /></td></tr>
<tr class="separator:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d09d77ada657a86decc99cc0319240f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a5d09d77ada657a86decc99cc0319240f">_alloc_pages</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> order)</td></tr>
<tr class="memdesc:a5d09d77ada657a86decc99cc0319240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated.  <a href="zone__allocator_8h.html#a5d09d77ada657a86decc99cc0319240f">More...</a><br /></td></tr>
<tr class="separator:a5d09d77ada657a86decc99cc0319240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78920bc7ec26ccf0813afe3eed2500bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a78920bc7ec26ccf0813afe3eed2500bb">get_virtual_address_from_page</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a78920bc7ec26ccf0813afe3eed2500bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a page structure to its corresponding low memory virtual address.  <a href="zone__allocator_8h.html#a78920bc7ec26ccf0813afe3eed2500bb">More...</a><br /></td></tr>
<tr class="separator:a78920bc7ec26ccf0813afe3eed2500bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab9b7ca23711b107872564fc5b70d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a0cab9b7ca23711b107872564fc5b70d0">get_physical_address_from_page</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a0cab9b7ca23711b107872564fc5b70d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a page structure to its corresponding physical address.  <a href="zone__allocator_8h.html#a0cab9b7ca23711b107872564fc5b70d0">More...</a><br /></td></tr>
<tr class="separator:a0cab9b7ca23711b107872564fc5b70d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7799ecc8bf4d01ca0e886916f0ad80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#aca7799ecc8bf4d01ca0e886916f0ad80">get_page_from_physical_address</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> paddr)</td></tr>
<tr class="memdesc:aca7799ecc8bf4d01ca0e886916f0ad80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the page structure corresponding to a given physical address.  <a href="zone__allocator_8h.html#aca7799ecc8bf4d01ca0e886916f0ad80">More...</a><br /></td></tr>
<tr class="separator:aca7799ecc8bf4d01ca0e886916f0ad80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae093a3ce10cc400d775d5bbbf860c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#aae093a3ce10cc400d775d5bbbf860c32">get_page_from_virtual_address</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> vaddr)</td></tr>
<tr class="memdesc:aae093a3ce10cc400d775d5bbbf860c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the low memory page corresponding to the given virtual address.  <a href="zone__allocator_8h.html#aae093a3ce10cc400d775d5bbbf860c32">More...</a><br /></td></tr>
<tr class="separator:aae093a3ce10cc400d775d5bbbf860c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50006b138d35b2796d29b2365aa26bee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a50006b138d35b2796d29b2365aa26bee">free_pages_lowmem</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr)</td></tr>
<tr class="memdesc:a50006b138d35b2796d29b2365aa26bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees from the given page frame address up to 2^order amount of page frames.  <a href="zone__allocator_8h.html#a50006b138d35b2796d29b2365aa26bee">More...</a><br /></td></tr>
<tr class="separator:a50006b138d35b2796d29b2365aa26bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#aafaab4bfa51ea8de8aaa583e8c6afbcb">__free_pages</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees from the given page frame address up to 2^order amount of page frames.  <a href="zone__allocator_8h.html#aafaab4bfa51ea8de8aaa583e8c6afbcb">More...</a><br /></td></tr>
<tr class="separator:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafa8397028625232f13bfaff534f77"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a4cafa8397028625232f13bfaff534f77">get_zone_total_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a4cafa8397028625232f13bfaff534f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the total space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8h.html#a4cafa8397028625232f13bfaff534f77">More...</a><br /></td></tr>
<tr class="separator:a4cafa8397028625232f13bfaff534f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1083d0ee8b656380a1edd1456d99c302"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a1083d0ee8b656380a1edd1456d99c302">get_zone_free_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a1083d0ee8b656380a1edd1456d99c302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the free space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8h.html#a1083d0ee8b656380a1edd1456d99c302">More...</a><br /></td></tr>
<tr class="separator:a1083d0ee8b656380a1edd1456d99c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e6f56e18e2159403d0453e6c5a706c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a72e6f56e18e2159403d0453e6c5a706c">get_zone_cached_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a72e6f56e18e2159403d0453e6c5a706c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the cached space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8h.html#a72e6f56e18e2159403d0453e6c5a706c">More...</a><br /></td></tr>
<tr class="separator:a72e6f56e18e2159403d0453e6c5a706c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af8a95b3eb57dba8b1b7b2b50a97ac3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#a8af8a95b3eb57dba8b1b7b2b50a97ac3">is_lowmem_page_struct</a> (void *addr)</td></tr>
<tr class="memdesc:a8af8a95b3eb57dba8b1b7b2b50a97ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified address points to a <a class="el" href="structpage__t.html" title="Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated.">page_t</a> (or field) that belongs to lowmem.  <a href="zone__allocator_8h.html#a8af8a95b3eb57dba8b1b7b2b50a97ac3">More...</a><br /></td></tr>
<tr class="separator:a8af8a95b3eb57dba8b1b7b2b50a97ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae0d9e415dc7508ce000d631b061bd72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#ae0d9e415dc7508ce000d631b061bd72c">mem_map</a></td></tr>
<tr class="memdesc:ae0d9e415dc7508ce000d631b061bd72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of all physical memory blocks (pages).  <a href="zone__allocator_8h.html#ae0d9e415dc7508ce000d631b061bd72c">More...</a><br /></td></tr>
<tr class="separator:ae0d9e415dc7508ce000d631b061bd72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpg__data__t.html">pg_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8h.html#aa3f4da00f7d0ba12f1f22c4002c4f831">contig_page_data</a></td></tr>
<tr class="memdesc:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory node descriptor for contiguous memory.  <a href="zone__allocator_8h.html#aa3f4da00f7d0ba12f1f22c4002c4f831">More...</a><br /></td></tr>
<tr class="separator:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the Zone Allocator. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2014-2024 This file is distributed under the MIT License. See LICENSE.md for details. </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0fdf79ffb0b79648e58d693137ccfada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdf79ffb0b79648e58d693137ccfada">&#9670;&nbsp;</a></span>zone_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="zone__allocator_8h.html#a0fdf79ffb0b79648e58d693137ccfada">zone_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration for <a class="el" href="structzone__t.html" title="Data structure to differentiate memory zone.">zone_t</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0fdf79ffb0b79648e58d693137ccfadaae04e3071b5aefe12178a93c7c616dd8b"></a>ZONE_NORMAL&#160;</td><td class="fielddoc"><p>Direct mapping. Used by the kernel. </p>
<p>Normal addressable memory is in <b>ZONE_NORMAL</b>. DMA operations can be performed on pages in <b>ZONE_NORMAL</b> if the DMA devices support transfers to all addressable memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fdf79ffb0b79648e58d693137ccfadaa274e4b70b8facd808390afd8833440f5"></a>ZONE_HIGHMEM&#160;</td><td class="fielddoc"><p>Page tables mapping. Used by user processes. </p>
<p>A memory area that is only addressable by the kernel through mapping portions into its own address space. This is for example used by i386 to allow the kernel to address the memory beyond 900MB. The kernel will set up special mappings (page table entries on i386) for each page that the kernel needs to access. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0fdf79ffb0b79648e58d693137ccfadaac210316b34bd6909d0a1b0126e39b286"></a>__MAX_NR_ZONES&#160;</td><td class="fielddoc"><p>The maximum number of zones. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9c0199ff865e2c2743b52925ba7ae94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0199ff865e2c2743b52925ba7ae94a">&#9670;&nbsp;</a></span>__alloc_page_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __alloc_page_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free page frame, set it allocated and return the memory address of the page frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The low memory address of the allocated page, or 0 if allocation fails. </dd></dl>

</div>
</div>
<a id="a323b63ab21ca69fd1f38c87c9f020b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323b63ab21ca69fd1f38c87c9f020b6c">&#9670;&nbsp;</a></span>__alloc_pages_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __alloc_pages_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
    <tr><td class="paramname">order</td><td>The logarithm of the size of the page frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory address of the first free page frame allocated. </dd></dl>

</div>
</div>
<a id="aafaab4bfa51ea8de8aaa583e8c6afbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaab4bfa51ea8de8aaa583e8c6afbcb">&#9670;&nbsp;</a></span>__free_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __free_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees from the given page frame address up to 2^order amount of page frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>The page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a5d09d77ada657a86decc99cc0319240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d09d77ada657a86decc99cc0319240f">&#9670;&nbsp;</a></span>_alloc_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* _alloc_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
    <tr><td class="paramname">order</td><td>The logarithm of the size of the page frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory address of the first free page frame allocated, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a04446abca7c9e3ddd590c6779952705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04446abca7c9e3ddd590c6779952705e">&#9670;&nbsp;</a></span>alloc_page_cached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* alloc_page_cached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a cached page based on the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated page, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a61f7fc07eb39b47fe33f8008050b1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f7fc07eb39b47fe33f8008050b1bda">&#9670;&nbsp;</a></span>find_nearest_order_greater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> find_nearest_order_greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest order of memory allocation that can accommodate a given amount of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_addr</td><td>the base address from which to calculate the number of pages. </td></tr>
    <tr><td class="paramname">amount</td><td>the amount of memory (in bytes) to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest order (power of two) that is greater than or equal to the number of pages required. </dd></dl>

</div>
</div>
<a id="a50f4eab4390517146b559c2abed5df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4eab4390517146b559c2abed5df0c">&#9670;&nbsp;</a></span>free_page_cached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_page_cached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a page allocated with alloc_page_cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a1117639df92ae7df60b82abb6ef363a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1117639df92ae7df60b82abb6ef363a0">&#9670;&nbsp;</a></span>free_page_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_page_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given page frame address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The block address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a50006b138d35b2796d29b2365aa26bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50006b138d35b2796d29b2365aa26bee">&#9670;&nbsp;</a></span>free_pages_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_pages_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees from the given page frame address up to 2^order amount of page frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The page frame address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="aca7799ecc8bf4d01ca0e886916f0ad80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7799ecc8bf4d01ca0e886916f0ad80">&#9670;&nbsp;</a></span>get_page_from_physical_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* get_page_from_physical_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the page structure corresponding to a given physical address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paddr</td><td>The physical address for which the page structure is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding page structure, or NULL if the address is invalid. </dd></dl>

</div>
</div>
<a id="aae093a3ce10cc400d775d5bbbf860c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae093a3ce10cc400d775d5bbbf860c32">&#9670;&nbsp;</a></span>get_page_from_virtual_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* get_page_from_virtual_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the low memory page corresponding to the given virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>the virtual address to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding page, or NULL if the address is out of range. </dd></dl>

</div>
</div>
<a id="a0cab9b7ca23711b107872564fc5b70d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab9b7ca23711b107872564fc5b70d0">&#9670;&nbsp;</a></span>get_physical_address_from_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> get_physical_address_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a page structure to its corresponding physical address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical address corresponding to the specified page, or 0 if the input page pointer is invalid. </dd></dl>

</div>
</div>
<a id="a78920bc7ec26ccf0813afe3eed2500bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78920bc7ec26ccf0813afe3eed2500bb">&#9670;&nbsp;</a></span>get_virtual_address_from_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> get_virtual_address_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a page structure to its corresponding low memory virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The low memory virtual address corresponding to the specified page, or 0 if the input page pointer is invalid. </dd></dl>

</div>
</div>
<a id="a72e6f56e18e2159403d0453e6c5a706c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e6f56e18e2159403d0453e6c5a706c">&#9670;&nbsp;</a></span>get_zone_cached_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_cached_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the cached space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="a1083d0ee8b656380a1edd1456d99c302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1083d0ee8b656380a1edd1456d99c302">&#9670;&nbsp;</a></span>get_zone_free_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_free_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the free space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The free space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="a4cafa8397028625232f13bfaff534f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafa8397028625232f13bfaff534f77">&#9670;&nbsp;</a></span>get_zone_total_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_total_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the total space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="a8af8a95b3eb57dba8b1b7b2b50a97ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af8a95b3eb57dba8b1b7b2b50a97ac3">&#9670;&nbsp;</a></span>is_lowmem_page_struct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_lowmem_page_struct </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified address points to a <a class="el" href="structpage__t.html" title="Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated.">page_t</a> (or field) that belongs to lowmem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if it belongs to lowmem, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ae118563b91978e181e76a04d77c50860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae118563b91978e181e76a04d77c50860">&#9670;&nbsp;</a></span>pmmngr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pmmngr_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboot__info__t.html">boot_info_t</a> *&#160;</td>
          <td class="paramname"><em>boot_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical memory manager initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boot_info</td><td>Information coming from the booloader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Outcome of the operation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa3f4da00f7d0ba12f1f22c4002c4f831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f4da00f7d0ba12f1f22c4002c4f831">&#9670;&nbsp;</a></span>contig_page_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpg__data__t.html">pg_data_t</a>* contig_page_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory node descriptor for contiguous memory. </p>
<p>This variable points to the <code><a class="el" href="structpg__data__t.html" title="Data structure to rapresent a memory node. In Uniform memory access (UMA) architectures there is only...">pg_data_t</a></code> structure, which represents a memory node (usually for NUMA systems). It typically describes the memory properties and zones for a contiguous block of physical memory. </p>

</div>
</div>
<a id="ae0d9e415dc7508ce000d631b061bd72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d9e415dc7508ce000d631b061bd72c">&#9670;&nbsp;</a></span>mem_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* mem_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of all physical memory blocks (pages). </p>
<p>This variable points to an array of <code><a class="el" href="structpage__t.html" title="Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated.">page_t</a></code> structures representing all physical memory blocks (pages) in the system. It is used to track the state of each page in memory. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
