<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MentOS: /home/enrico/repository/personal/mentos/mentos/src/mem/zone_allocator.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MentOS
   &#160;<span id="projectnumber">0.8.0</span>
   </div>
   <div id="projectbrief">The Mentoring Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b4d46abdb8cafe1ad6c14fa0f9992e34.html">mentos</a></li><li class="navelem"><a class="el" href="dir_d299fed5c83b024e8b5c525a233be574.html">src</a></li><li class="navelem"><a class="el" href="dir_08b6eaf56fb9bda47473cca56ca9e53c.html">mem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">zone_allocator.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Implementation of the Zone Allocator.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae88fdea60e151933ce52a92938897dac"><td class="memItemLeft" align="right" valign="top"><a id="ae88fdea60e151933ce52a92938897dac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ae88fdea60e151933ce52a92938897dac">__DEBUG_HEADER__</a>&#160;&#160;&#160;&quot;[PMM   ]&quot;</td></tr>
<tr class="memdesc:ae88fdea60e151933ce52a92938897dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change header. <br /></td></tr>
<tr class="separator:ae88fdea60e151933ce52a92938897dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7dc04a8b1423d105b10f7af0720c"><td class="memItemLeft" align="right" valign="top"><a id="a785e7dc04a8b1423d105b10f7af0720c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a785e7dc04a8b1423d105b10f7af0720c">__DEBUG_LEVEL__</a>&#160;&#160;&#160;<a class="el" href="kernel__levels_8h.html#a4377191d729d923509b6953555776d80">LOGLEVEL_NOTICE</a></td></tr>
<tr class="memdesc:a785e7dc04a8b1423d105b10f7af0720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level. <br /></td></tr>
<tr class="separator:a785e7dc04a8b1423d105b10f7af0720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947746dc0435a69c3d7e288b368b01fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a947746dc0435a69c3d7e288b368b01fd">MIN_PAGE_ALIGN</a>(addr)&#160;&#160;&#160;((addr) &amp; (~(<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> - 1)))</td></tr>
<tr class="memdesc:a947746dc0435a69c3d7e288b368b01fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the given address down to the nearest page boundary.  <a href="zone__allocator_8c.html#a947746dc0435a69c3d7e288b368b01fd">More...</a><br /></td></tr>
<tr class="separator:a947746dc0435a69c3d7e288b368b01fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7a1f5a05f0becbe5921f9ae1a6a859"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#acb7a1f5a05f0becbe5921f9ae1a6a859">MAX_PAGE_ALIGN</a>(addr)&#160;&#160;&#160;(((addr) &amp; (~(<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> - 1))) + <a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>)</td></tr>
<tr class="memdesc:acb7a1f5a05f0becbe5921f9ae1a6a859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the given address up to the nearest page boundary.  <a href="zone__allocator_8c.html#acb7a1f5a05f0becbe5921f9ae1a6a859">More...</a><br /></td></tr>
<tr class="separator:acb7a1f5a05f0becbe5921f9ae1a6a859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb91fbaa1727f8d15ea1c895f457c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a9dbb91fbaa1727f8d15ea1c895f457c1">MIN_ORDER_ALIGN</a>(addr)&#160;&#160;&#160;((addr) &amp; (~((<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> &lt;&lt; (<a class="el" href="buddysystem_8h.html#ae37b6e1e072ece327b9e6bbd9a2f862d">MAX_BUDDYSYSTEM_GFP_ORDER</a> - 1)) - 1)))</td></tr>
<tr class="memdesc:a9dbb91fbaa1727f8d15ea1c895f457c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the given address down to the nearest order boundary.  <a href="zone__allocator_8c.html#a9dbb91fbaa1727f8d15ea1c895f457c1">More...</a><br /></td></tr>
<tr class="separator:a9dbb91fbaa1727f8d15ea1c895f457c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b538d07e8e12860185fbd3fb151309f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a1b538d07e8e12860185fbd3fb151309f">MAX_ORDER_ALIGN</a>(addr)</td></tr>
<tr class="memdesc:a1b538d07e8e12860185fbd3fb151309f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns the given address up to the nearest order boundary.  <a href="zone__allocator_8c.html#a1b538d07e8e12860185fbd3fb151309f">More...</a><br /></td></tr>
<tr class="separator:a1b538d07e8e12860185fbd3fb151309f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a78920bc7ec26ccf0813afe3eed2500bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a78920bc7ec26ccf0813afe3eed2500bb">get_virtual_address_from_page</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a78920bc7ec26ccf0813afe3eed2500bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a page structure to its corresponding low memory virtual address.  <a href="zone__allocator_8c.html#a78920bc7ec26ccf0813afe3eed2500bb">More...</a><br /></td></tr>
<tr class="separator:a78920bc7ec26ccf0813afe3eed2500bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab9b7ca23711b107872564fc5b70d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a0cab9b7ca23711b107872564fc5b70d0">get_physical_address_from_page</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a0cab9b7ca23711b107872564fc5b70d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a page structure to its corresponding physical address.  <a href="zone__allocator_8c.html#a0cab9b7ca23711b107872564fc5b70d0">More...</a><br /></td></tr>
<tr class="separator:a0cab9b7ca23711b107872564fc5b70d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae093a3ce10cc400d775d5bbbf860c32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#aae093a3ce10cc400d775d5bbbf860c32">get_page_from_virtual_address</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> vaddr)</td></tr>
<tr class="memdesc:aae093a3ce10cc400d775d5bbbf860c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the low memory page corresponding to the given virtual address.  <a href="zone__allocator_8c.html#aae093a3ce10cc400d775d5bbbf860c32">More...</a><br /></td></tr>
<tr class="separator:aae093a3ce10cc400d775d5bbbf860c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217103b82871ca7b78acfe9222fe4e15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a217103b82871ca7b78acfe9222fe4e15">get_page_from_physical_address</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> phy_addr)</td></tr>
<tr class="memdesc:a217103b82871ca7b78acfe9222fe4e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the page structure corresponding to a given physical address.  <a href="zone__allocator_8c.html#a217103b82871ca7b78acfe9222fe4e15">More...</a><br /></td></tr>
<tr class="separator:a217103b82871ca7b78acfe9222fe4e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba699051d46743b64c144a5a30fc5b53"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structzone__t.html">zone_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#aba699051d46743b64c144a5a30fc5b53">get_zone_from_page</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:aba699051d46743b64c144a5a30fc5b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the zone that contains a page frame.  <a href="zone__allocator_8c.html#aba699051d46743b64c144a5a30fc5b53">More...</a><br /></td></tr>
<tr class="separator:aba699051d46743b64c144a5a30fc5b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228d3c16a3fc71fc55d2db6c9871a095"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structzone__t.html">zone_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a228d3c16a3fc71fc55d2db6c9871a095">get_zone_from_flags</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a228d3c16a3fc71fc55d2db6c9871a095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a zone from the specified GFP mask.  <a href="zone__allocator_8c.html#a228d3c16a3fc71fc55d2db6c9871a095">More...</a><br /></td></tr>
<tr class="separator:a228d3c16a3fc71fc55d2db6c9871a095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aaa79c21dfe5b8fcb18374b1ef9409"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ad2aaa79c21dfe5b8fcb18374b1ef9409">is_memory_clean</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:ad2aaa79c21dfe5b8fcb18374b1ef9409"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the specified memory zone is clean (i.e., all pages are free).  <a href="zone__allocator_8c.html#ad2aaa79c21dfe5b8fcb18374b1ef9409">More...</a><br /></td></tr>
<tr class="separator:ad2aaa79c21dfe5b8fcb18374b1ef9409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5271f0e3ee3e41eb0760a02558df186"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ab5271f0e3ee3e41eb0760a02558df186">pmm_check</a> (void)</td></tr>
<tr class="memdesc:ab5271f0e3ee3e41eb0760a02558df186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the physical memory manager is working properly.  <a href="zone__allocator_8c.html#ab5271f0e3ee3e41eb0760a02558df186">More...</a><br /></td></tr>
<tr class="separator:ab5271f0e3ee3e41eb0760a02558df186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78173d71149766db27353af254346309"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a78173d71149766db27353af254346309">zone_init</a> (char *name, int zone_index, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> adr_from, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> adr_to)</td></tr>
<tr class="memdesc:a78173d71149766db27353af254346309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the memory attributes for a specified zone.  <a href="zone__allocator_8c.html#a78173d71149766db27353af254346309">More...</a><br /></td></tr>
<tr class="separator:a78173d71149766db27353af254346309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cde07d0c8701fdfa4bc9bbd77555f2f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a0cde07d0c8701fdfa4bc9bbd77555f2f">find_nearest_order_greater</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> base_addr, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> amount)</td></tr>
<tr class="memdesc:a0cde07d0c8701fdfa4bc9bbd77555f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest order of memory allocation that can accommodate a given amount of memory.  <a href="zone__allocator_8c.html#a0cde07d0c8701fdfa4bc9bbd77555f2f">More...</a><br /></td></tr>
<tr class="separator:a0cde07d0c8701fdfa4bc9bbd77555f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae118563b91978e181e76a04d77c50860"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ae118563b91978e181e76a04d77c50860">pmmngr_init</a> (<a class="el" href="structboot__info__t.html">boot_info_t</a> *<a class="el" href="kernel_8c.html#a6fb24e311419027d49f1cab853a9a9ac">boot_info</a>)</td></tr>
<tr class="memdesc:ae118563b91978e181e76a04d77c50860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical memory manager initialization.  <a href="zone__allocator_8c.html#ae118563b91978e181e76a04d77c50860">More...</a><br /></td></tr>
<tr class="separator:ae118563b91978e181e76a04d77c50860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04446abca7c9e3ddd590c6779952705e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a04446abca7c9e3ddd590c6779952705e">alloc_page_cached</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a04446abca7c9e3ddd590c6779952705e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a cached page based on the given GFP mask.  <a href="zone__allocator_8c.html#a04446abca7c9e3ddd590c6779952705e">More...</a><br /></td></tr>
<tr class="separator:a04446abca7c9e3ddd590c6779952705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4eab4390517146b559c2abed5df0c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a50f4eab4390517146b559c2abed5df0c">free_page_cached</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:a50f4eab4390517146b559c2abed5df0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free a page allocated with alloc_page_cached.  <a href="zone__allocator_8c.html#a50f4eab4390517146b559c2abed5df0c">More...</a><br /></td></tr>
<tr class="separator:a50f4eab4390517146b559c2abed5df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0199ff865e2c2743b52925ba7ae94a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a9c0199ff865e2c2743b52925ba7ae94a">__alloc_page_lowmem</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a9c0199ff865e2c2743b52925ba7ae94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free page frame, set it allocated and return the memory address of the page frame.  <a href="zone__allocator_8c.html#a9c0199ff865e2c2743b52925ba7ae94a">More...</a><br /></td></tr>
<tr class="separator:a9c0199ff865e2c2743b52925ba7ae94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1117639df92ae7df60b82abb6ef363a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a1117639df92ae7df60b82abb6ef363a0">free_page_lowmem</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr)</td></tr>
<tr class="memdesc:a1117639df92ae7df60b82abb6ef363a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the given page frame address.  <a href="zone__allocator_8c.html#a1117639df92ae7df60b82abb6ef363a0">More...</a><br /></td></tr>
<tr class="separator:a1117639df92ae7df60b82abb6ef363a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a323b63ab21ca69fd1f38c87c9f020b6c">__alloc_pages_lowmem</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> order)</td></tr>
<tr class="memdesc:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated.  <a href="zone__allocator_8c.html#a323b63ab21ca69fd1f38c87c9f020b6c">More...</a><br /></td></tr>
<tr class="separator:a323b63ab21ca69fd1f38c87c9f020b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d09d77ada657a86decc99cc0319240f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a5d09d77ada657a86decc99cc0319240f">_alloc_pages</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> order)</td></tr>
<tr class="memdesc:a5d09d77ada657a86decc99cc0319240f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated.  <a href="zone__allocator_8c.html#a5d09d77ada657a86decc99cc0319240f">More...</a><br /></td></tr>
<tr class="separator:a5d09d77ada657a86decc99cc0319240f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50006b138d35b2796d29b2365aa26bee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a50006b138d35b2796d29b2365aa26bee">free_pages_lowmem</a> (<a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr)</td></tr>
<tr class="memdesc:a50006b138d35b2796d29b2365aa26bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees from the given page frame address up to 2^order amount of page frames.  <a href="zone__allocator_8c.html#a50006b138d35b2796d29b2365aa26bee">More...</a><br /></td></tr>
<tr class="separator:a50006b138d35b2796d29b2365aa26bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#aafaab4bfa51ea8de8aaa583e8c6afbcb">__free_pages</a> (<a class="el" href="structpage__t.html">page_t</a> *page)</td></tr>
<tr class="memdesc:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees from the given page frame address up to 2^order amount of page frames.  <a href="zone__allocator_8c.html#aafaab4bfa51ea8de8aaa583e8c6afbcb">More...</a><br /></td></tr>
<tr class="separator:aafaab4bfa51ea8de8aaa583e8c6afbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafa8397028625232f13bfaff534f77"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a4cafa8397028625232f13bfaff534f77">get_zone_total_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a4cafa8397028625232f13bfaff534f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the total space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8c.html#a4cafa8397028625232f13bfaff534f77">More...</a><br /></td></tr>
<tr class="separator:a4cafa8397028625232f13bfaff534f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1083d0ee8b656380a1edd1456d99c302"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a1083d0ee8b656380a1edd1456d99c302">get_zone_free_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a1083d0ee8b656380a1edd1456d99c302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the free space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8c.html#a1083d0ee8b656380a1edd1456d99c302">More...</a><br /></td></tr>
<tr class="separator:a1083d0ee8b656380a1edd1456d99c302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e6f56e18e2159403d0453e6c5a706c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a72e6f56e18e2159403d0453e6c5a706c">get_zone_cached_space</a> (<a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> gfp_mask)</td></tr>
<tr class="memdesc:a72e6f56e18e2159403d0453e6c5a706c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the cached space of the zone corresponding to the given GFP mask.  <a href="zone__allocator_8c.html#a72e6f56e18e2159403d0453e6c5a706c">More...</a><br /></td></tr>
<tr class="separator:a72e6f56e18e2159403d0453e6c5a706c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae0d9e415dc7508ce000d631b061bd72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ae0d9e415dc7508ce000d631b061bd72c">mem_map</a> = <a class="el" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:ae0d9e415dc7508ce000d631b061bd72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of all physical memory blocks (pages).  <a href="zone__allocator_8c.html#ae0d9e415dc7508ce000d631b061bd72c">More...</a><br /></td></tr>
<tr class="separator:ae0d9e415dc7508ce000d631b061bd72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpg__data__t.html">pg_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#aa3f4da00f7d0ba12f1f22c4002c4f831">contig_page_data</a> = <a class="el" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td></tr>
<tr class="memdesc:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory node descriptor for contiguous memory.  <a href="zone__allocator_8c.html#aa3f4da00f7d0ba12f1f22c4002c4f831">More...</a><br /></td></tr>
<tr class="separator:aa3f4da00f7d0ba12f1f22c4002c4f831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6700510dc261519a55bdadbb96e8d19e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a6700510dc261519a55bdadbb96e8d19e">lowmem_virt_base</a> = 0</td></tr>
<tr class="memdesc:a6700510dc261519a55bdadbb96e8d19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base address of the low memory (lowmem) zone.  <a href="zone__allocator_8c.html#a6700510dc261519a55bdadbb96e8d19e">More...</a><br /></td></tr>
<tr class="separator:a6700510dc261519a55bdadbb96e8d19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e66bffaef505b7b09b3ca61cfa7ed75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a9e66bffaef505b7b09b3ca61cfa7ed75">lowmem_page_base</a> = 0</td></tr>
<tr class="memdesc:a9e66bffaef505b7b09b3ca61cfa7ed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical base address of the low memory (lowmem) zone.  <a href="zone__allocator_8c.html#a9e66bffaef505b7b09b3ca61cfa7ed75">More...</a><br /></td></tr>
<tr class="separator:a9e66bffaef505b7b09b3ca61cfa7ed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fddeb46688d9ae8a9bff4f628a09d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ad3fddeb46688d9ae8a9bff4f628a09d3">lowmem_phy_start</a></td></tr>
<tr class="memdesc:ad3fddeb46688d9ae8a9bff4f628a09d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Physical start address of low memory (lowmem) zone.  <a href="zone__allocator_8c.html#ad3fddeb46688d9ae8a9bff4f628a09d3">More...</a><br /></td></tr>
<tr class="separator:ad3fddeb46688d9ae8a9bff4f628a09d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c3f35d34b7277d24c6e2b89563c7d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a94c3f35d34b7277d24c6e2b89563c7d4">lowmem_virt_start</a></td></tr>
<tr class="memdesc:a94c3f35d34b7277d24c6e2b89563c7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual start address of low memory (lowmem) zone.  <a href="zone__allocator_8c.html#a94c3f35d34b7277d24c6e2b89563c7d4">More...</a><br /></td></tr>
<tr class="separator:a94c3f35d34b7277d24c6e2b89563c7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f6a3b0b58cbdacf4ce9a0c9b3d64794"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a3f6a3b0b58cbdacf4ce9a0c9b3d64794">mem_size</a></td></tr>
<tr class="memdesc:a3f6a3b0b58cbdacf4ce9a0c9b3d64794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of available physical memory in bytes.  <a href="zone__allocator_8c.html#a3f6a3b0b58cbdacf4ce9a0c9b3d64794">More...</a><br /></td></tr>
<tr class="separator:a3f6a3b0b58cbdacf4ce9a0c9b3d64794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3762625256855f3d4b6f18b3f490e6bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a3762625256855f3d4b6f18b3f490e6bf">mem_map_num</a></td></tr>
<tr class="memdesc:a3762625256855f3d4b6f18b3f490e6bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of memory frames (pages) available.  <a href="zone__allocator_8c.html#a3762625256855f3d4b6f18b3f490e6bf">More...</a><br /></td></tr>
<tr class="separator:a3762625256855f3d4b6f18b3f490e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f92c63e0653d8a6bd1219bcd7feff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a33f92c63e0653d8a6bd1219bcd7feff9">normal_start_addr</a></td></tr>
<tr class="memdesc:a33f92c63e0653d8a6bd1219bcd7feff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start address of the normal (lowmem) zone.  <a href="zone__allocator_8c.html#a33f92c63e0653d8a6bd1219bcd7feff9">More...</a><br /></td></tr>
<tr class="separator:a33f92c63e0653d8a6bd1219bcd7feff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0e8b889e0f4b9c4880b20aeb5c8f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a5a0e8b889e0f4b9c4880b20aeb5c8f4c">normal_end_addr</a></td></tr>
<tr class="memdesc:a5a0e8b889e0f4b9c4880b20aeb5c8f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">End address of the normal (lowmem) zone.  <a href="zone__allocator_8c.html#a5a0e8b889e0f4b9c4880b20aeb5c8f4c">More...</a><br /></td></tr>
<tr class="separator:a5a0e8b889e0f4b9c4880b20aeb5c8f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6a7f44cf15a5126b6d5a72b6d7691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ad0b6a7f44cf15a5126b6d5a72b6d7691">normal_size</a></td></tr>
<tr class="memdesc:ad0b6a7f44cf15a5126b6d5a72b6d7691"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of the normal (lowmem) zone.  <a href="zone__allocator_8c.html#ad0b6a7f44cf15a5126b6d5a72b6d7691">More...</a><br /></td></tr>
<tr class="separator:ad0b6a7f44cf15a5126b6d5a72b6d7691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6bf752028045a2daf1236e5b248bce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#ab6bf752028045a2daf1236e5b248bce1">high_start_addr</a></td></tr>
<tr class="memdesc:ab6bf752028045a2daf1236e5b248bce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start address of the high memory (highmem) zone.  <a href="zone__allocator_8c.html#ab6bf752028045a2daf1236e5b248bce1">More...</a><br /></td></tr>
<tr class="separator:ab6bf752028045a2daf1236e5b248bce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777fed454fe6d9f1bea882e1964048e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a777fed454fe6d9f1bea882e1964048e2">high_end_addr</a></td></tr>
<tr class="memdesc:a777fed454fe6d9f1bea882e1964048e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">End address of the high memory (highmem) zone.  <a href="zone__allocator_8c.html#a777fed454fe6d9f1bea882e1964048e2">More...</a><br /></td></tr>
<tr class="separator:a777fed454fe6d9f1bea882e1964048e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4db91973cdacadc6308032bea73002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zone__allocator_8c.html#a1a4db91973cdacadc6308032bea73002">high_size</a></td></tr>
<tr class="memdesc:a1a4db91973cdacadc6308032bea73002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total size of the high memory (highmem) zone.  <a href="zone__allocator_8c.html#a1a4db91973cdacadc6308032bea73002">More...</a><br /></td></tr>
<tr class="separator:a1a4db91973cdacadc6308032bea73002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the Zone Allocator. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2014-2024 This file is distributed under the MIT License. See LICENSE.md for details. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1b538d07e8e12860185fbd3fb151309f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b538d07e8e12860185fbd3fb151309f">&#9670;&nbsp;</a></span>MAX_ORDER_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_ORDER_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    (((addr) &amp; (~((<a class="code" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> &lt;&lt; (<a class="code" href="buddysystem_8h.html#ae37b6e1e072ece327b9e6bbd9a2f862d">MAX_BUDDYSYSTEM_GFP_ORDER</a> - 1)) - 1))) + \</div>
<div class="line">     (<a class="code" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> &lt;&lt; (<a class="code" href="buddysystem_8h.html#ae37b6e1e072ece327b9e6bbd9a2f862d">MAX_BUDDYSYSTEM_GFP_ORDER</a> - 1)))</div>
<div class="ttc" id="abuddysystem_8h_html_ae37b6e1e072ece327b9e6bbd9a2f862d"><div class="ttname"><a href="buddysystem_8h.html#ae37b6e1e072ece327b9e6bbd9a2f862d">MAX_BUDDYSYSTEM_GFP_ORDER</a></div><div class="ttdeci">#define MAX_BUDDYSYSTEM_GFP_ORDER</div><div class="ttdoc">Max gfp pages order of buddysystem blocks.</div><div class="ttdef"><b>Definition:</b> buddysystem.h:13</div></div>
<div class="ttc" id="apaging_8h_html_a7d467c1d283fdfa1f2081ba1e0d01b6e"><div class="ttname"><a href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a></div><div class="ttdeci">#define PAGE_SIZE</div><div class="ttdoc">Size of a page (4096 bytes).</div><div class="ttdef"><b>Definition:</b> paging.h:18</div></div>
</div><!-- fragment -->
<p>Aligns the given address up to the nearest order boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to align. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned address. </dd></dl>

</div>
</div>
<a id="acb7a1f5a05f0becbe5921f9ae1a6a859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb7a1f5a05f0becbe5921f9ae1a6a859">&#9670;&nbsp;</a></span>MAX_PAGE_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_PAGE_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;(((addr) &amp; (~(<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> - 1))) + <a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the given address up to the nearest page boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to align. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned address. </dd></dl>

</div>
</div>
<a id="a9dbb91fbaa1727f8d15ea1c895f457c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbb91fbaa1727f8d15ea1c895f457c1">&#9670;&nbsp;</a></span>MIN_ORDER_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_ORDER_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;((addr) &amp; (~((<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> &lt;&lt; (<a class="el" href="buddysystem_8h.html#ae37b6e1e072ece327b9e6bbd9a2f862d">MAX_BUDDYSYSTEM_GFP_ORDER</a> - 1)) - 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the given address down to the nearest order boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to align. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned address. </dd></dl>

</div>
</div>
<a id="a947746dc0435a69c3d7e288b368b01fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947746dc0435a69c3d7e288b368b01fd">&#9670;&nbsp;</a></span>MIN_PAGE_ALIGN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN_PAGE_ALIGN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;((addr) &amp; (~(<a class="el" href="paging_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a> - 1)))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aligns the given address down to the nearest page boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The address to align. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The aligned address. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9c0199ff865e2c2743b52925ba7ae94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0199ff865e2c2743b52925ba7ae94a">&#9670;&nbsp;</a></span>__alloc_page_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __alloc_page_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free page frame, set it allocated and return the memory address of the page frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The low memory address of the allocated page, or 0 if allocation fails. </dd></dl>

</div>
</div>
<a id="a323b63ab21ca69fd1f38c87c9f020b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323b63ab21ca69fd1f38c87c9f020b6c">&#9670;&nbsp;</a></span>__alloc_pages_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> __alloc_pages_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
    <tr><td class="paramname">order</td><td>The logarithm of the size of the page frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory address of the first free page frame allocated. </dd></dl>

</div>
</div>
<a id="aafaab4bfa51ea8de8aaa583e8c6afbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaab4bfa51ea8de8aaa583e8c6afbcb">&#9670;&nbsp;</a></span>__free_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int __free_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees from the given page frame address up to 2^order amount of page frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>The page. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a5d09d77ada657a86decc99cc0319240f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d09d77ada657a86decc99cc0319240f">&#9670;&nbsp;</a></span>_alloc_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* _alloc_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first free 2^order amount of page frames, set it allocated and return the memory address of the first page frame allocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP_FLAGS to decide the zone allocation. </td></tr>
    <tr><td class="paramname">order</td><td>The logarithm of the size of the page frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Memory address of the first free page frame allocated, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a04446abca7c9e3ddd590c6779952705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04446abca7c9e3ddd590c6779952705e">&#9670;&nbsp;</a></span>alloc_page_cached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* alloc_page_cached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a cached page based on the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the allocated page, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a0cde07d0c8701fdfa4bc9bbd77555f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cde07d0c8701fdfa4bc9bbd77555f2f">&#9670;&nbsp;</a></span>find_nearest_order_greater()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int find_nearest_order_greater </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>base_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest order of memory allocation that can accommodate a given amount of memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base_addr</td><td>the base address from which to calculate the number of pages. </td></tr>
    <tr><td class="paramname">amount</td><td>the amount of memory (in bytes) to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The nearest order (power of two) that is greater than or equal to the number of pages required. </dd></dl>

</div>
</div>
<a id="a50f4eab4390517146b559c2abed5df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4eab4390517146b559c2abed5df0c">&#9670;&nbsp;</a></span>free_page_cached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_page_cached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free a page allocated with alloc_page_cached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page to free. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a1117639df92ae7df60b82abb6ef363a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1117639df92ae7df60b82abb6ef363a0">&#9670;&nbsp;</a></span>free_page_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_page_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the given page frame address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The block address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a50006b138d35b2796d29b2365aa26bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50006b138d35b2796d29b2365aa26bee">&#9670;&nbsp;</a></span>free_pages_lowmem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int free_pages_lowmem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees from the given page frame address up to 2^order amount of page frames. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>The page frame address. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a217103b82871ca7b78acfe9222fe4e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a217103b82871ca7b78acfe9222fe4e15">&#9670;&nbsp;</a></span>get_page_from_physical_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* get_page_from_physical_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>paddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the page structure corresponding to a given physical address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paddr</td><td>The physical address for which the page structure is requested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding page structure, or NULL if the address is invalid. </dd></dl>

</div>
</div>
<a id="aae093a3ce10cc400d775d5bbbf860c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae093a3ce10cc400d775d5bbbf860c32">&#9670;&nbsp;</a></span>get_page_from_virtual_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* get_page_from_virtual_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>vaddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the low memory page corresponding to the given virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vaddr</td><td>the virtual address to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the corresponding page, or NULL if the address is out of range. </dd></dl>

</div>
</div>
<a id="a0cab9b7ca23711b107872564fc5b70d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab9b7ca23711b107872564fc5b70d0">&#9670;&nbsp;</a></span>get_physical_address_from_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> get_physical_address_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a page structure to its corresponding physical address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The physical address corresponding to the specified page, or 0 if the input page pointer is invalid. </dd></dl>

</div>
</div>
<a id="a78920bc7ec26ccf0813afe3eed2500bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78920bc7ec26ccf0813afe3eed2500bb">&#9670;&nbsp;</a></span>get_virtual_address_from_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> get_virtual_address_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a page structure to its corresponding low memory virtual address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>Pointer to the page structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The low memory virtual address corresponding to the specified page, or 0 if the input page pointer is invalid. </dd></dl>

</div>
</div>
<a id="a72e6f56e18e2159403d0453e6c5a706c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e6f56e18e2159403d0453e6c5a706c">&#9670;&nbsp;</a></span>get_zone_cached_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_cached_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the cached space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="a1083d0ee8b656380a1edd1456d99c302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1083d0ee8b656380a1edd1456d99c302">&#9670;&nbsp;</a></span>get_zone_free_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_free_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the free space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The free space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="a228d3c16a3fc71fc55d2db6c9871a095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228d3c16a3fc71fc55d2db6c9871a095">&#9670;&nbsp;</a></span>get_zone_from_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structzone__t.html">zone_t</a>* get_zone_from_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a zone from the specified GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>GFP flags indicating the type of memory allocation request. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the requested zone, or NULL if the gfp_mask is not recognized. </dd></dl>

</div>
</div>
<a id="aba699051d46743b64c144a5a30fc5b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba699051d46743b64c144a5a30fc5b53">&#9670;&nbsp;</a></span>get_zone_from_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structzone__t.html">zone_t</a>* get_zone_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the zone that contains a page frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">page</td><td>A pointer to the page descriptor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the zone containing the page, or NULL if the page is not within any zone. </dd></dl>

</div>
</div>
<a id="a4cafa8397028625232f13bfaff534f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafa8397028625232f13bfaff534f77">&#9670;&nbsp;</a></span>get_zone_total_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long get_zone_total_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the total space of the zone corresponding to the given GFP mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The GFP mask specifying the allocation constraints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total space of the zone, or 0 if the zone cannot be retrieved. </dd></dl>

</div>
</div>
<a id="ad2aaa79c21dfe5b8fcb18374b1ef9409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2aaa79c21dfe5b8fcb18374b1ef9409">&#9670;&nbsp;</a></span>is_memory_clean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int is_memory_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>gfp_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the specified memory zone is clean (i.e., all pages are free). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gfp_mask</td><td>The mask that specifies the zone of interest for memory allocation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the memory is clean, 0 if there is an error or if the memory is not clean. </dd></dl>

</div>
</div>
<a id="ab5271f0e3ee3e41eb0760a02558df186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5271f0e3ee3e41eb0760a02558df186">&#9670;&nbsp;</a></span>pmm_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int pmm_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the physical memory manager is working properly. </p>
<dl class="section return"><dt>Returns</dt><dd>If the check was done correctly. </dd></dl>

</div>
</div>
<a id="ae118563b91978e181e76a04d77c50860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae118563b91978e181e76a04d77c50860">&#9670;&nbsp;</a></span>pmmngr_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pmmngr_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboot__info__t.html">boot_info_t</a> *&#160;</td>
          <td class="paramname"><em>boot_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical memory manager initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boot_info</td><td>Information coming from the booloader. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Outcome of the operation. </dd></dl>

</div>
</div>
<a id="a78173d71149766db27353af254346309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78173d71149766db27353af254346309">&#9670;&nbsp;</a></span>zone_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int zone_init </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zone_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>adr_from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>adr_to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes the memory attributes for a specified zone. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The zone's name. </td></tr>
    <tr><td class="paramname">zone_index</td><td>The zone's index, which must be valid within the number of zones. </td></tr>
    <tr><td class="paramname">adr_from</td><td>The lowest address of the zone (inclusive). </td></tr>
    <tr><td class="paramname">adr_to</td><td>The highest address of the zone (exclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa3f4da00f7d0ba12f1f22c4002c4f831"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f4da00f7d0ba12f1f22c4002c4f831">&#9670;&nbsp;</a></span>contig_page_data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpg__data__t.html">pg_data_t</a>* contig_page_data = <a class="el" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Memory node descriptor for contiguous memory. </p>
<p>This variable points to the <code><a class="el" href="structpg__data__t.html" title="Data structure to rapresent a memory node. In Uniform memory access (UMA) architectures there is only...">pg_data_t</a></code> structure, which represents a memory node (usually for NUMA systems). It typically describes the memory properties and zones for a contiguous block of physical memory. </p>

</div>
</div>
<a id="a777fed454fe6d9f1bea882e1964048e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777fed454fe6d9f1bea882e1964048e2">&#9670;&nbsp;</a></span>high_end_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> high_end_addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End address of the high memory (highmem) zone. </p>
<p>This variable holds the ending physical address of the high memory zone, which marks the limit of available physical memory. </p>

</div>
</div>
<a id="a1a4db91973cdacadc6308032bea73002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4db91973cdacadc6308032bea73002">&#9670;&nbsp;</a></span>high_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> high_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total size of the high memory (highmem) zone. </p>
<p>The size of the high memory zone in bytes. High memory requires special handling as it is not directly accessible by the kernel's virtual address space. </p>

</div>
</div>
<a id="ab6bf752028045a2daf1236e5b248bce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6bf752028045a2daf1236e5b248bce1">&#9670;&nbsp;</a></span>high_start_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> high_start_addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start address of the high memory (highmem) zone. </p>
<p>This variable stores the starting physical address of the high memory zone, which is memory not directly addressable by the kernel and requires special handling. </p>

</div>
</div>
<a id="a9e66bffaef505b7b09b3ca61cfa7ed75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e66bffaef505b7b09b3ca61cfa7ed75">&#9670;&nbsp;</a></span>lowmem_page_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> lowmem_page_base = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical base address of the low memory (lowmem) zone. </p>
<p>This variable stores the base physical address of the low memory region. It represents the starting point of the lowmem pages in physical memory. </p>

</div>
</div>
<a id="ad3fddeb46688d9ae8a9bff4f628a09d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fddeb46688d9ae8a9bff4f628a09d3">&#9670;&nbsp;</a></span>lowmem_phy_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> lowmem_phy_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Physical start address of low memory (lowmem) zone. </p>
<p>This variable stores the physical address where the low memory (which is directly addressable by the kernel) begins. </p>

</div>
</div>
<a id="a6700510dc261519a55bdadbb96e8d19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6700510dc261519a55bdadbb96e8d19e">&#9670;&nbsp;</a></span>lowmem_virt_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> lowmem_virt_base = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual base address of the low memory (lowmem) zone. </p>
<p>This variable stores the base virtual address of the low memory region. The kernel uses this address to access low memory (directly addressable memory). </p>

</div>
</div>
<a id="a94c3f35d34b7277d24c6e2b89563c7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c3f35d34b7277d24c6e2b89563c7d4">&#9670;&nbsp;</a></span>lowmem_virt_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> lowmem_virt_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Virtual start address of low memory (lowmem) zone. </p>
<p>This variable stores the virtual address corresponding to the start of the low memory region in the kernel's virtual address space. </p>

</div>
</div>
<a id="ae0d9e415dc7508ce000d631b061bd72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d9e415dc7508ce000d631b061bd72c">&#9670;&nbsp;</a></span>mem_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpage__t.html">page_t</a>* mem_map = <a class="el" href="stddef_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of all physical memory blocks (pages). </p>
<p>This variable points to an array of <code><a class="el" href="structpage__t.html" title="Page descriptor. Use as a bitmap to understand the order of the block and if it is free or allocated.">page_t</a></code> structures representing all physical memory blocks (pages) in the system. It is used to track the state of each page in memory. </p>

</div>
</div>
<a id="a3762625256855f3d4b6f18b3f490e6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3762625256855f3d4b6f18b3f490e6bf">&#9670;&nbsp;</a></span>mem_map_num</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> mem_map_num</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total number of memory frames (pages) available. </p>
<p>The number of physical memory frames available in the system, calculated as the total memory divided by the size of a memory page. </p>

</div>
</div>
<a id="a3f6a3b0b58cbdacf4ce9a0c9b3d64794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f6a3b0b58cbdacf4ce9a0c9b3d64794">&#9670;&nbsp;</a></span>mem_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> mem_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total size of available physical memory in bytes. </p>
<p>This variable holds the total amount of memory available on the system (both low and high memory). </p>

</div>
</div>
<a id="a5a0e8b889e0f4b9c4880b20aeb5c8f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0e8b889e0f4b9c4880b20aeb5c8f4c">&#9670;&nbsp;</a></span>normal_end_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> normal_end_addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End address of the normal (lowmem) zone. </p>
<p>This variable holds the ending physical address of the normal memory zone (low memory), marking the boundary between lowmem and highmem. </p>

</div>
</div>
<a id="ad0b6a7f44cf15a5126b6d5a72b6d7691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b6a7f44cf15a5126b6d5a72b6d7691">&#9670;&nbsp;</a></span>normal_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> normal_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total size of the normal (lowmem) zone. </p>
<p>The size of the normal memory zone in bytes, which is the portion of memory directly addressable by the kernel. </p>

</div>
</div>
<a id="a33f92c63e0653d8a6bd1219bcd7feff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f92c63e0653d8a6bd1219bcd7feff9">&#9670;&nbsp;</a></span>normal_start_addr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> normal_start_addr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start address of the normal (lowmem) zone. </p>
<p>This variable holds the starting physical address of the normal memory zone, also known as low memory, which is directly addressable by the kernel. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
