<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MentOS: /home/enrico/repository/personal/mentos/mentos/src/mem/slab.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MentOS
   &#160;<span id="projectnumber">0.7.3</span>
   </div>
   <div id="projectbrief">The Mentoring Operating System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b4d46abdb8cafe1ad6c14fa0f9992e34.html">mentos</a></li><li class="navelem"><a class="el" href="dir_d299fed5c83b024e8b5c525a233be574.html">src</a></li><li class="navelem"><a class="el" href="dir_08b6eaf56fb9bda47473cca56ca9e53c.html">mem</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">slab.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory slab allocator implementation in kernel. This file provides functions for managing memory allocation using the slab allocator technique. Slab allocators are efficient in managing frequent small memory allocations with minimal fragmentation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structkmem__obj.html">kmem_obj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to represent an individual memory object within a slab.  <a href="structkmem__obj.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae88fdea60e151933ce52a92938897dac"><td class="memItemLeft" align="right" valign="top"><a id="ae88fdea60e151933ce52a92938897dac"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ae88fdea60e151933ce52a92938897dac">__DEBUG_HEADER__</a>&#160;&#160;&#160;&quot;[SLAB  ]&quot;</td></tr>
<tr class="memdesc:ae88fdea60e151933ce52a92938897dac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change header. <br /></td></tr>
<tr class="separator:ae88fdea60e151933ce52a92938897dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785e7dc04a8b1423d105b10f7af0720c"><td class="memItemLeft" align="right" valign="top"><a id="a785e7dc04a8b1423d105b10f7af0720c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a785e7dc04a8b1423d105b10f7af0720c">__DEBUG_LEVEL__</a>&#160;&#160;&#160;<a class="el" href="kernel__levels_8h.html#a4377191d729d923509b6953555776d80">LOGLEVEL_NOTICE</a></td></tr>
<tr class="memdesc:a785e7dc04a8b1423d105b10f7af0720c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level. <br /></td></tr>
<tr class="separator:a785e7dc04a8b1423d105b10f7af0720c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6bddd90e1ea06f9cae8dd11a663b07"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#aca6bddd90e1ea06f9cae8dd11a663b07">MAX_KMALLOC_CACHE_ORDER</a>&#160;&#160;&#160;12</td></tr>
<tr class="memdesc:aca6bddd90e1ea06f9cae8dd11a663b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum order of kmalloc cache allocations.  <a href="slab_8c.html#aca6bddd90e1ea06f9cae8dd11a663b07">More...</a><br /></td></tr>
<tr class="separator:aca6bddd90e1ea06f9cae8dd11a663b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9081162232acb2671767b5e1d1243a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a7a9081162232acb2671767b5e1d1243a">KMEM_OBJ_OVERHEAD</a>&#160;&#160;&#160;sizeof(<a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a>)</td></tr>
<tr class="memdesc:a7a9081162232acb2671767b5e1d1243a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overhead size for each memory object in the slab cache.  <a href="slab_8c.html#a7a9081162232acb2671767b5e1d1243a">More...</a><br /></td></tr>
<tr class="separator:a7a9081162232acb2671767b5e1d1243a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829fced4c53e05a8147517eac9151014"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a829fced4c53e05a8147517eac9151014">KMEM_START_OBJ_COUNT</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a829fced4c53e05a8147517eac9151014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial object count for each slab.  <a href="slab_8c.html#a829fced4c53e05a8147517eac9151014">More...</a><br /></td></tr>
<tr class="separator:a829fced4c53e05a8147517eac9151014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4558aa7cde2d6d61b682cf2106c6303"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ad4558aa7cde2d6d61b682cf2106c6303">KMEM_MAX_REFILL_OBJ_COUNT</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ad4558aa7cde2d6d61b682cf2106c6303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of objects to refill in a slab cache at once.  <a href="slab_8c.html#ad4558aa7cde2d6d61b682cf2106c6303">More...</a><br /></td></tr>
<tr class="separator:ad4558aa7cde2d6d61b682cf2106c6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dca98f6d746de82f30874e29897a90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ad4dca98f6d746de82f30874e29897a90">KMEM_OBJ_FROM_ADDR</a>(addr)&#160;&#160;&#160;((<a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a> *)(addr))</td></tr>
<tr class="memdesc:ad4dca98f6d746de82f30874e29897a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to convert an address into a <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> pointer.  <a href="slab_8c.html#ad4dca98f6d746de82f30874e29897a90">More...</a><br /></td></tr>
<tr class="separator:ad4dca98f6d746de82f30874e29897a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7143692c2f56bf741c1596f48b3c2c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#aa7143692c2f56bf741c1596f48b3c2c6">ADDR_FROM_KMEM_OBJ</a>(object)&#160;&#160;&#160;((void *)(object))</td></tr>
<tr class="memdesc:aa7143692c2f56bf741c1596f48b3c2c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to get the address from a <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> structure.  <a href="slab_8c.html#aa7143692c2f56bf741c1596f48b3c2c6">More...</a><br /></td></tr>
<tr class="separator:aa7143692c2f56bf741c1596f48b3c2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4d758fb43afa1796e82ba3387bcbc344"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structkmem__obj.html">kmem_obj</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a></td></tr>
<tr class="memdesc:a4d758fb43afa1796e82ba3387bcbc344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to represent an individual memory object within a slab.  <a href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">More...</a><br /></td></tr>
<tr class="separator:a4d758fb43afa1796e82ba3387bcbc344"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa1f2dc4c80ac17dd70d50c6bb938df3"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#aaa1f2dc4c80ac17dd70d50c6bb938df3">__alloc_slab_page</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, <a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> flags)</td></tr>
<tr class="memdesc:aaa1f2dc4c80ac17dd70d50c6bb938df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes a new slab page for a memory cache.  <a href="slab_8c.html#aaa1f2dc4c80ac17dd70d50c6bb938df3">More...</a><br /></td></tr>
<tr class="separator:aaa1f2dc4c80ac17dd70d50c6bb938df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ce984dd0d1a4454d6a786cbb4a2f0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a281ce984dd0d1a4454d6a786cbb4a2f0">__kmem_cache_refill</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, unsigned int free_num, <a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> flags)</td></tr>
<tr class="memdesc:a281ce984dd0d1a4454d6a786cbb4a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refills a memory cache with new slab pages to reach a specified number of free objects.  <a href="slab_8c.html#a281ce984dd0d1a4454d6a786cbb4a2f0">More...</a><br /></td></tr>
<tr class="separator:a281ce984dd0d1a4454d6a786cbb4a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4927a6a2d0c06c24774b379b434cc200"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a4927a6a2d0c06c24774b379b434cc200">__compute_size_and_order</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep)</td></tr>
<tr class="memdesc:a4927a6a2d0c06c24774b379b434cc200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and sets the size and gfp order for a memory cache.  <a href="slab_8c.html#a4927a6a2d0c06c24774b379b434cc200">More...</a><br /></td></tr>
<tr class="separator:a4927a6a2d0c06c24774b379b434cc200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1965c660704d49f9b0653ac31454c7e9"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a1965c660704d49f9b0653ac31454c7e9">__kmem_cache_create</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, const char *name, unsigned int size, unsigned int align, <a class="el" href="slab_8h.html#ac64b2b0ba1b2c6ff968690157b05f7e6">slab_flags_t</a> flags, <a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a> ctor, <a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a> dtor, unsigned int start_count)</td></tr>
<tr class="memdesc:a1965c660704d49f9b0653ac31454c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes and creates a new memory cache.  <a href="slab_8c.html#a1965c660704d49f9b0653ac31454c7e9">More...</a><br /></td></tr>
<tr class="separator:a1965c660704d49f9b0653ac31454c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518b33cd6b60dd7b00f01500b0ac0b38"><td class="memItemLeft" align="right" valign="top">static void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a518b33cd6b60dd7b00f01500b0ac0b38">__kmem_cache_alloc_slab</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, <a class="el" href="structpage__t.html">page_t</a> *slab_page)</td></tr>
<tr class="memdesc:a518b33cd6b60dd7b00f01500b0ac0b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object from a specified slab page.  <a href="slab_8c.html#a518b33cd6b60dd7b00f01500b0ac0b38">More...</a><br /></td></tr>
<tr class="separator:a518b33cd6b60dd7b00f01500b0ac0b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d184acfe705241d025c242524f17c6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ad2d184acfe705241d025c242524f17c6">__kmem_cache_free_slab</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, <a class="el" href="structpage__t.html">page_t</a> *slab_page)</td></tr>
<tr class="memdesc:ad2d184acfe705241d025c242524f17c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a slab page and updates the associated cache statistics.  <a href="slab_8c.html#ad2d184acfe705241d025c242524f17c6">More...</a><br /></td></tr>
<tr class="separator:ad2d184acfe705241d025c242524f17c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18b8b87ecbc92682de8bccf373bda61"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ac18b8b87ecbc92682de8bccf373bda61">kmem_cache_init</a> (void)</td></tr>
<tr class="memdesc:ac18b8b87ecbc92682de8bccf373bda61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the kernel memory cache system.  <a href="slab_8c.html#ac18b8b87ecbc92682de8bccf373bda61">More...</a><br /></td></tr>
<tr class="separator:ac18b8b87ecbc92682de8bccf373bda61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16fedab1a1b676d16c34774fc78657f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ad16fedab1a1b676d16c34774fc78657f">kmem_cache_create</a> (const char *name, unsigned int size, unsigned int align, <a class="el" href="slab_8h.html#ac64b2b0ba1b2c6ff968690157b05f7e6">slab_flags_t</a> flags, <a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a> ctor, <a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a> dtor)</td></tr>
<tr class="memdesc:ad16fedab1a1b676d16c34774fc78657f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new kmem_cache structure.  <a href="slab_8c.html#ad16fedab1a1b676d16c34774fc78657f">More...</a><br /></td></tr>
<tr class="separator:ad16fedab1a1b676d16c34774fc78657f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae087f5ac59692349a7d3fefe607a0dc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ae087f5ac59692349a7d3fefe607a0dc6">kmem_cache_destroy</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep)</td></tr>
<tr class="memdesc:ae087f5ac59692349a7d3fefe607a0dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a specified kmem_cache structure.  <a href="slab_8c.html#ae087f5ac59692349a7d3fefe607a0dc6">More...</a><br /></td></tr>
<tr class="separator:ae087f5ac59692349a7d3fefe607a0dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d06cf91e5fab6317cd5a704007f1871"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a1d06cf91e5fab6317cd5a704007f1871">kmem_cache_alloc</a> (<a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *cachep, <a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a> flags)</td></tr>
<tr class="memdesc:a1d06cf91e5fab6317cd5a704007f1871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an object from the specified <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a>.  <a href="slab_8c.html#a1d06cf91e5fab6317cd5a704007f1871">More...</a><br /></td></tr>
<tr class="separator:a1d06cf91e5fab6317cd5a704007f1871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abd2b1f7525604a7be896b3ff0ab370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a1abd2b1f7525604a7be896b3ff0ab370">kmem_cache_free</a> (void *ptr)</td></tr>
<tr class="memdesc:a1abd2b1f7525604a7be896b3ff0ab370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees an object previously allocated from a <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a>.  <a href="slab_8c.html#a1abd2b1f7525604a7be896b3ff0ab370">More...</a><br /></td></tr>
<tr class="separator:a1abd2b1f7525604a7be896b3ff0ab370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a6d6d6d860a3dd67eb762ee84a2a8368c">kmalloc</a> (unsigned int size)</td></tr>
<tr class="memdesc:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory of the specified size using kmalloc.  <a href="slab_8c.html#a6d6d6d860a3dd67eb762ee84a2a8368c">More...</a><br /></td></tr>
<tr class="separator:a6d6d6d860a3dd67eb762ee84a2a8368c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069f85a5001d71bc44d8be6532a4e432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a069f85a5001d71bc44d8be6532a4e432">kfree</a> (void *ptr)</td></tr>
<tr class="memdesc:a069f85a5001d71bc44d8be6532a4e432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees memory allocated by kmalloc or kmem_cache_alloc.  <a href="slab_8c.html#a069f85a5001d71bc44d8be6532a4e432">More...</a><br /></td></tr>
<tr class="separator:a069f85a5001d71bc44d8be6532a4e432"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac6b46478613ef8fb1731f355df09c585"><td class="memItemLeft" align="right" valign="top"><a id="ac6b46478613ef8fb1731f355df09c585"></a>
static list_head&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#ac6b46478613ef8fb1731f355df09c585">kmem_caches_list</a></td></tr>
<tr class="memdesc:ac6b46478613ef8fb1731f355df09c585"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of all active memory caches in the system. <br /></td></tr>
<tr class="separator:ac6b46478613ef8fb1731f355df09c585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5c4b70f12a9704c99807c62a609313"><td class="memItemLeft" align="right" valign="top"><a id="abb5c4b70f12a9704c99807c62a609313"></a>
static <a class="el" href="structkmem__cache__t.html">kmem_cache_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#abb5c4b70f12a9704c99807c62a609313">kmem_cache</a></td></tr>
<tr class="memdesc:abb5c4b70f12a9704c99807c62a609313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cache used for managing metadata about the memory caches themselves. <br /></td></tr>
<tr class="separator:abb5c4b70f12a9704c99807c62a609313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d55a8dc4d874680b8c3e57a5364a2e"><td class="memItemLeft" align="right" valign="top"><a id="a89d55a8dc4d874680b8c3e57a5364a2e"></a>
static <a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="slab_8c.html#a89d55a8dc4d874680b8c3e57a5364a2e">malloc_blocks</a> [<a class="el" href="slab_8c.html#aca6bddd90e1ea06f9cae8dd11a663b07">MAX_KMALLOC_CACHE_ORDER</a>]</td></tr>
<tr class="memdesc:a89d55a8dc4d874680b8c3e57a5364a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of slab caches for different orders of kmalloc. <br /></td></tr>
<tr class="separator:a89d55a8dc4d874680b8c3e57a5364a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Memory slab allocator implementation in kernel. This file provides functions for managing memory allocation using the slab allocator technique. Slab allocators are efficient in managing frequent small memory allocations with minimal fragmentation. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>(c) 2014-2024 This file is distributed under the MIT License. See LICENSE.md for details. </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa7143692c2f56bf741c1596f48b3c2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7143692c2f56bf741c1596f48b3c2c6">&#9670;&nbsp;</a></span>ADDR_FROM_KMEM_OBJ</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ADDR_FROM_KMEM_OBJ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">object</td><td>)</td>
          <td>&#160;&#160;&#160;((void *)(object))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to get the address from a <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Pointer to the <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the object as a <code>void *</code>. </dd></dl>

</div>
</div>
<a id="ad4558aa7cde2d6d61b682cf2106c6303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4558aa7cde2d6d61b682cf2106c6303">&#9670;&nbsp;</a></span>KMEM_MAX_REFILL_OBJ_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KMEM_MAX_REFILL_OBJ_COUNT&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of objects to refill in a slab cache at once. </p>
<p>This defines the upper limit on how many objects to replenish in the slab when it runs out of free objects. </p>

</div>
</div>
<a id="ad4dca98f6d746de82f30874e29897a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dca98f6d746de82f30874e29897a90">&#9670;&nbsp;</a></span>KMEM_OBJ_FROM_ADDR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KMEM_OBJ_FROM_ADDR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addr</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a> *)(addr))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to convert an address into a <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Address of the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to a <a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a> structure. </dd></dl>

</div>
</div>
<a id="a7a9081162232acb2671767b5e1d1243a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9081162232acb2671767b5e1d1243a">&#9670;&nbsp;</a></span>KMEM_OBJ_OVERHEAD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KMEM_OBJ_OVERHEAD&#160;&#160;&#160;sizeof(<a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overhead size for each memory object in the slab cache. </p>
<p>This defines the extra space required for managing the object, including the <code><a class="el" href="structkmem__obj.html" title="Structure to represent an individual memory object within a slab.">kmem_obj</a></code> structure itself. </p>

</div>
</div>
<a id="a829fced4c53e05a8147517eac9151014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829fced4c53e05a8147517eac9151014">&#9670;&nbsp;</a></span>KMEM_START_OBJ_COUNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KMEM_START_OBJ_COUNT&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial object count for each slab. </p>
<p>The starting number of objects in a newly allocated slab cache. </p>

</div>
</div>
<a id="aca6bddd90e1ea06f9cae8dd11a663b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6bddd90e1ea06f9cae8dd11a663b07">&#9670;&nbsp;</a></span>MAX_KMALLOC_CACHE_ORDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_KMALLOC_CACHE_ORDER&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum order of kmalloc cache allocations. </p>
<p>If a requested memory allocation exceeds this order, a raw page allocation is done instead of using the slab cache. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4d758fb43afa1796e82ba3387bcbc344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d758fb43afa1796e82ba3387bcbc344">&#9670;&nbsp;</a></span>kmem_obj_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structkmem__obj.html">kmem_obj</a> <a class="el" href="slab_8c.html#a4d758fb43afa1796e82ba3387bcbc344">kmem_obj_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure to represent an individual memory object within a slab. </p>
<p>This structure is used to manage individual objects allocated from the slab. It contains a linked list to connect objects in the cache. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa1f2dc4c80ac17dd70d50c6bb938df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1f2dc4c80ac17dd70d50c6bb938df3">&#9670;&nbsp;</a></span>__alloc_slab_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __alloc_slab_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates and initializes a new slab page for a memory cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the memory cache (<code><a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a></code>) for which a new slab page is being allocated. </td></tr>
    <tr><td class="paramname">flags</td><td>Allocation flags (e.g., GFP_KERNEL) passed to control memory allocation behavior. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a4927a6a2d0c06c24774b379b434cc200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4927a6a2d0c06c24774b379b434cc200">&#9670;&nbsp;</a></span>__compute_size_and_order()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __compute_size_and_order </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes and sets the size and gfp order for a memory cache. </p>
<p>This function adjusts the size of objects in the cache based on padding and alignment requirements, and calculates the <code>gfp_order</code> (number of contiguous pages) needed for slab allocations. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the memory cache (<code><a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a></code>) whose size and order are being computed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a518b33cd6b60dd7b00f01500b0ac0b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518b33cd6b60dd7b00f01500b0ac0b38">&#9670;&nbsp;</a></span>__kmem_cache_alloc_slab()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void* __kmem_cache_alloc_slab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>slab_page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates an object from a specified slab page. </p>
<p>This function retrieves a free object from the given slab page's free list. It decrements the count of free objects in both the slab page and the cache. If the constructor function is defined, it will be called to initialize the object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the cache from which the object is being allocated. </td></tr>
    <tr><td class="paramname">slab_page</td><td>Pointer to the slab page from which to allocate the object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated object, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a1965c660704d49f9b0653ac31454c7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1965c660704d49f9b0653ac31454c7e9">&#9670;&nbsp;</a></span>__kmem_cache_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __kmem_cache_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac64b2b0ba1b2c6ff968690157b05f7e6">slab_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a>&#160;</td>
          <td class="paramname"><em>ctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a>&#160;</td>
          <td class="paramname"><em>dtor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>start_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes and creates a new memory cache. </p>
<p>This function sets up a new memory cache (<code><a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a></code>) with the provided parameters such as object size, alignment, constructor/destructor functions, and flags. It also initializes slab lists, computes the appropriate size and order, refills the cache with objects, and adds it to the global cache list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the memory cache structure to initialize. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the cache. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the objects to be allocated from the cache. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment requirement for the objects. </td></tr>
    <tr><td class="paramname">flags</td><td>Slab allocation flags. </td></tr>
    <tr><td class="paramname">ctor</td><td>Constructor function to initialize objects (optional, can be NULL). </td></tr>
    <tr><td class="paramname">dtor</td><td>Destructor function to clean up objects (optional, can be NULL). </td></tr>
    <tr><td class="paramname">start_count</td><td>Initial number of objects to populate in the cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="ad2d184acfe705241d025c242524f17c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d184acfe705241d025c242524f17c6">&#9670;&nbsp;</a></span>__kmem_cache_free_slab()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __kmem_cache_free_slab </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__t.html">page_t</a> *&#160;</td>
          <td class="paramname"><em>slab_page</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees a slab page and updates the associated cache statistics. </p>
<p>This function updates the total and free object counts in the cache and resets the slab page's metadata to indicate that it is no longer in use. It also frees the memory associated with the slab page. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the cache from which the slab page is being freed. </td></tr>
    <tr><td class="paramname">slab_page</td><td>Pointer to the slab page to be freed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a281ce984dd0d1a4454d6a786cbb4a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a281ce984dd0d1a4454d6a786cbb4a2f0">&#9670;&nbsp;</a></span>__kmem_cache_refill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int __kmem_cache_refill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>free_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Refills a memory cache with new slab pages to reach a specified number of free objects. </p>
<p>This function allocates new slab pages as needed until the cache has at least <code>free_num</code> free objects. If a page allocation fails, the refill process is aborted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the memory cache (<code><a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a></code>) that needs to be refilled. </td></tr>
    <tr><td class="paramname">free_num</td><td>The desired number of free objects in the cache. </td></tr>
    <tr><td class="paramname">flags</td><td>Allocation flags used for controlling memory allocation behavior (e.g., GFP_KERNEL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure. </dd></dl>

</div>
</div>
<a id="a069f85a5001d71bc44d8be6532a4e432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069f85a5001d71bc44d8be6532a4e432">&#9670;&nbsp;</a></span>kfree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kfree </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees memory allocated by kmalloc or kmem_cache_alloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the memory to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d6d6d860a3dd67eb762ee84a2a8368c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6d6d860a3dd67eb762ee84a2a8368c">&#9670;&nbsp;</a></span>kmalloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* kmalloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory of the specified size using kmalloc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the memory to allocate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated memory, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="a1d06cf91e5fab6317cd5a704007f1871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d06cf91e5fab6317cd5a704007f1871">&#9670;&nbsp;</a></span>kmem_cache_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* kmem_cache_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gfp_8h.html#a99dcacb83509949e516cf6ae0367ff73">gfp_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates an object from the specified <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the cache from which to allocate the object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for the allocation (e.g., GFP_KERNEL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the allocated object, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="ad16fedab1a1b676d16c34774fc78657f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16fedab1a1b676d16c34774fc78657f">&#9670;&nbsp;</a></span>kmem_cache_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a>* kmem_cache_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac64b2b0ba1b2c6ff968690157b05f7e6">slab_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a>&#160;</td>
          <td class="paramname"><em>ctor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="slab_8h.html#ac35c078abe51cc52f5eb93a4287a2bbb">kmem_fun_t</a>&#160;</td>
          <td class="paramname"><em>dtor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new kmem_cache structure. </p>
<p>This function allocates memory for a new cache and initializes it with the provided parameters. The cache is ready for use after this function returns. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the cache. </td></tr>
    <tr><td class="paramname">size</td><td>Size of each object in the cache. </td></tr>
    <tr><td class="paramname">align</td><td>Alignment requirement for objects in the cache. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags for slab allocation. </td></tr>
    <tr><td class="paramname">ctor</td><td>Constructor function for initializing objects (can be NULL). </td></tr>
    <tr><td class="paramname">dtor</td><td>Destructor function for cleaning up objects (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the newly created <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a>, or NULL if allocation fails. </dd></dl>

</div>
</div>
<a id="ae087f5ac59692349a7d3fefe607a0dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae087f5ac59692349a7d3fefe607a0dc6">&#9670;&nbsp;</a></span>kmem_cache_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmem_cache_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmem__cache__t.html">kmem_cache_t</a> *&#160;</td>
          <td class="paramname"><em>cachep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a specified kmem_cache structure. </p>
<p>This function cleans up and frees all memory associated with the specified cache, including all associated slab pages. After calling this function, the cache should no longer be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cachep</td><td>Pointer to the <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a> structure to destroy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
<a id="a1abd2b1f7525604a7be896b3ff0ab370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abd2b1f7525604a7be896b3ff0ab370">&#9670;&nbsp;</a></span>kmem_cache_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kmem_cache_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees an object previously allocated from a <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Pointer to the object to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac18b8b87ecbc92682de8bccf373bda61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18b8b87ecbc92682de8bccf373bda61">&#9670;&nbsp;</a></span>kmem_cache_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int kmem_cache_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the kernel memory cache system. </p>
<p>This function initializes the global cache list and creates the main cache for managing <a class="el" href="structkmem__cache__t.html" title="Stores the information of a cache.">kmem_cache_t</a> structures. It also creates caches for different order sizes for kmalloc allocations. </p><dl class="section note"><dt>Note</dt><dd>This function should be called during system initialization. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or -1 if an error occurs. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
